# Задачи для js

## Задача №1

У нас есть следующий объект:

```
let user = {
  name: "John",
  age: 30
};
```

Проверьте, что этот объект не пустой и что в нем есть ключ age.

## Задача №2

Имеется массив объектов:

```
let users = [
	{
		name: "John",
		age: 30
	},
	{
		name: "Bob",
		age: 21
	},
	{
		name: "Anna",
		age: 19
	}
]
```

Получите из этого массива объект, где name == "Bob" и сохраните это в какой-либо переменной.

## Задача №3

Удалите из массива объектов (задание 2) объект с name == "Anna".

## Задача №4

Отсортируйте массив объектов в пункте 2 по свойству age в порядке возрастания.

## Задача №5

Даны два массива — orders и statuses. В orders хранятся данные по заказам, в statuses возможные статусы заказа (от создания до доставки):

Создать функцию changeStatus, которая принимает как параметр id заказа и меняет статус на следующий по цепочке из массива
statuses и statusChangeTime на текущее. Функция должна возвращать объект следующего вида:

```
{
	status: 'success' / 'error',
	message: 'Статус заказа <id заказа> изменен на "<новый статус заказа>"' / <Текст ошибки в свободной форме>,
}
```

```
const orders = [
	{
		id: '24003874339',
		status: 'Передано в SAP',
		statusChangeTime:
			'Sun Oct 24 2021 10:24:00 GMT+0300 (Москва, стандартное время)',
	},
	{
		id: '010001247991',
		status: 'Доставлен',
		statusChangeTime:
			'Mon May 24 2021 11:59:00 GMT+0300 (Москва, стандартное время)',
	},
	{
		id: '13030778733',
		status: 'Ожидает оплаты',
		statusChangeTime:
			'Mon Oct 25 2021 15:45:00 GMT+0300 (Москва, стандартное время)',
	},
	{
		id: '010001247987',
		status: 'Аннулирован',
		statusChangeTime:
			'Thu Dec 12 2019 19:52:00 GMT+0300 (Москва, стандартное время)',
	},
	{
		id: 'DB000006008',
		status: 'Новый',
		statusChangeTime:
			'Mon Oct 25 2021 16:50:00 GMT+0300 (Москва, стандартное время)',
	},
]

const statuses = ['Новый', 'Ожидает оплаты', 'Передано в SAP', 'Доставлен']
const nonChangebleStatuses = ['Доставлен', 'Аннулирован']
```

## Задача №6

Нам нужна простая функция, которая определяет, нужно ли использовать множественное число или нет. Она должна принимать число и возвращать значение true, если с этим числом следует использовать множественное число, или false, если нет. Это было бы полезно при выводе строки, например, "5 минут", "14 яблок" или "1 солнце".

Вам нужно только позаботиться о правилах английской грамматики для этого ката, где все, что не является единственным числом (одним из чего-либо), является множественным числом (не одним из чего-либо).

Все значения будут целыми положительными числами, числами с плавающей точкой или нулем.

## Задача №7

Однажды, давным-давно, на пути через старый дикий горный запад,…
...человеку дали указания, как добраться из одной точки в другую. Это были направления "СЕВЕР", "ЮГ", "ЗАПАД", "ВОСТОК". Очевидно, что "СЕВЕР" и "ЮГ" противоположны, "ЗАПАД" и "ВОСТОК" тоже.

Идти в одном направлении и сразу же возвращаться в противоположном - бесполезное усилие. Поскольку это дикий Запад, с ужасной погодой и нехваткой воды, важно экономить энергию, иначе вы можете умереть от жажды!

**Как я разумно пересек горную пустыню.**
Мужчине даны, например, следующие инструкции (в зависимости от языка).:

```
["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST"].
or
{ "NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST" };
or
[North, South, South, East, West, North, West]
```

Вы сразу увидите, что идти "на СЕВЕР" и сразу "на ЮГ" неразумно, лучше оставаться на одном и том же месте! Итак, задача состоит в том, чтобы дать мужчине упрощенный вариант плана. Лучший план в данном случае - это просто:

```
["WEST"]
or
{ "WEST" }
or
[West]
```

**Другие примеры**

В ["NORTH", "SOUTH", "EAST", "WEST"], направление "NORTH" + "SOUTH" означает движение на север и немедленное возвращение обратно.

Путь становится ["EAST", "WEST"], теперь "EAST" и "WEST" уничтожают друг друга, следовательно, конечный результат равен [] (ноль в Clojure).

В ["NORTH", "EAST", "WEST", "SOUTH", "WEST", "WEST"], "NORTH" и "SOUTH" не являются прямо противоположными, но они становятся прямо противоположными после сокращения "EAST" and "WEST", так что весь путь можно сократить на ["WEST", "WEST"].

**_Задание_**

Напишите функцию dirReduc, которая будет принимать массив строк и возвращать массив строк с удаленными ненужными указаниями (W<->E или S<->N рядом).

**Смотрите больше примеров в разделе "Примеры тестов":**

- Не все пути можно упростить. Путь ["NORTH", "WEST", "SOUTH", "EAST"] не поддается сокращению. "NORTH" и "WEST", "WEST" и "SOUTH", "SOUTH" и "EAST" не являются прямыми противоположностями друг друга и не могут стать таковыми. Следовательно, результирующий путь сам по себе: ["NORTH", "WEST", "SOUTH", "EAST"].
- если вы хотите перевести, пожалуйста, спросите об этом перед переводом.
